{"version":3,"sources":["utils/contenthashToUri.ts","utils/ENS/parseENSAddress.ts","utils/uriToHttp.ts","utils/getTokenList.ts"],"names":["UTF_8_DECODER","TextDecoder","contenthashToUri","contenthash","buff","hex","startsWith","substr","length","Error","arr","Uint8Array","i","parseInt","hexToUint8Array","codec","getCodec","data","rmPrefix","cid","CID","toB58String","multihash","decode","name","digest","trim","ENS_NAME_REGEX","parseENSAddress","ensAddress","match","ensName","toLowerCase","ensPath","uriToHttp","uri","split","hash","tokenListValidator","Ajv","allErrors","compile","schema","getTokenList","listUrl","resolveENSContentHash","a","parsedENS","contentHashUri","console","error","translatedUri","urls","url","isLast","response","fetch","ok","json","validationErrors","errors","reduce","memo","add","dataPath","message"],"mappings":"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","file":"static/js/8.67639324.chunk.js","sourcesContent":["import CID from 'cids'\r\nimport { getCodec, rmPrefix } from 'multicodec'\r\nimport { decode, toB58String } from 'multihashes'\r\n\r\nfunction hexToUint8Array(hex: string): Uint8Array {\r\n  // eslint-disable-next-line no-param-reassign\r\n  hex = hex.startsWith('0x') ? hex.substr(2) : hex\r\n  if (hex.length % 2 !== 0) throw new Error('hex must have length that is multiple of 2')\r\n  const arr = new Uint8Array(hex.length / 2)\r\n  for (let i = 0; i < arr.length; i++) {\r\n    arr[i] = parseInt(hex.substr(i * 2, 2), 16)\r\n  }\r\n  return arr\r\n}\r\n\r\nconst UTF_8_DECODER = new TextDecoder()\r\n\r\n/**\r\n * Returns the URI representation of the content hash for supported codecs\r\n * @param contenthash to decode\r\n */\r\nexport default function contenthashToUri(contenthash: string): string {\r\n  const buff = hexToUint8Array(contenthash)\r\n  const codec = getCodec(buff as Buffer) // the typing is wrong for @types/multicodec\r\n  switch (codec) {\r\n    case 'ipfs-ns': {\r\n      const data = rmPrefix(buff as Buffer)\r\n      const cid = new CID(data)\r\n      return `ipfs://${toB58String(cid.multihash)}`\r\n    }\r\n    case 'ipns-ns': {\r\n      const data = rmPrefix(buff as Buffer)\r\n      const cid = new CID(data)\r\n      const multihash = decode(cid.multihash)\r\n      if (multihash.name === 'identity') {\r\n        return `ipns://${UTF_8_DECODER.decode(multihash.digest).trim()}`\r\n      }\r\n      return `ipns://${toB58String(cid.multihash)}`\r\n    }\r\n    default:\r\n      throw new Error(`Unrecognized codec: ${codec}`)\r\n  }\r\n}\r\n","const ENS_NAME_REGEX = /^(([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+)eth(\\/.*)?$/\r\n\r\nexport function parseENSAddress(ensAddress: string): { ensName: string; ensPath: string | undefined } | undefined {\r\n  const match = ensAddress.match(ENS_NAME_REGEX)\r\n  if (!match) return undefined\r\n  return { ensName: `${match[1].toLowerCase()}eth`, ensPath: match[4] }\r\n}\r\n\r\nexport default parseENSAddress\r\n","/* eslint-disable no-case-declarations */\r\n/**\r\n * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content\r\n * @param uri to convert to fetch-able http url\r\n */\r\nexport default function uriToHttp(uri: string): string[] {\r\n  const protocol = uri.split(':')[0].toLowerCase()\r\n  switch (protocol) {\r\n    case 'https':\r\n      return [uri]\r\n    case 'http':\r\n      return [`https${uri.substr(4)}`, uri]\r\n    case 'ipfs':\r\n      const hash = uri.match(/^ipfs:(\\/\\/)?(.*)$/i)?.[2]\r\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`]\r\n    case 'ipns':\r\n      const name = uri.match(/^ipns:(\\/\\/)?(.*)$/i)?.[2]\r\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`]\r\n    default:\r\n      return []\r\n  }\r\n}\r\n","/* eslint-disable no-continue */\r\n/* eslint-disable no-await-in-loop */\r\nimport { TokenList } from '@uniswap/token-lists'\r\nimport schema from '@uniswap/token-lists/src/tokenlist.schema.json'\r\nimport Ajv from 'ajv'\r\nimport contenthashToUri from './contenthashToUri'\r\nimport { parseENSAddress } from './ENS/parseENSAddress'\r\nimport uriToHttp from './uriToHttp'\r\n\r\nconst tokenListValidator = new Ajv({ allErrors: true }).compile(schema)\r\n\r\n/**\r\n * Contains the logic for resolving a list URL to a validated token list\r\n * @param listUrl list url\r\n * @param resolveENSContentHash resolves an ens name to a contenthash\r\n */\r\nexport default async function getTokenList(\r\n  listUrl: string,\r\n  resolveENSContentHash: (ensName: string) => Promise<string>,\r\n): Promise<TokenList> {\r\n  const parsedENS = parseENSAddress(listUrl)\r\n  let urls: string[]\r\n  if (parsedENS) {\r\n    let contentHashUri\r\n    try {\r\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName)\r\n    } catch (error) {\r\n      console.error(`Failed to resolve ENS name: ${parsedENS.ensName}`, error)\r\n      throw new Error(`Failed to resolve ENS name: ${parsedENS.ensName}`)\r\n    }\r\n    let translatedUri\r\n    try {\r\n      translatedUri = contenthashToUri(contentHashUri)\r\n    } catch (error) {\r\n      console.error('Failed to translate contenthash to URI', contentHashUri)\r\n      throw new Error(`Failed to translate contenthash to URI: ${contentHashUri}`)\r\n    }\r\n    urls = uriToHttp(`${translatedUri}${parsedENS.ensPath ?? ''}`)\r\n  } else {\r\n    urls = uriToHttp(listUrl)\r\n  }\r\n  for (let i = 0; i < urls.length; i++) {\r\n    const url = urls[i]\r\n    const isLast = i === urls.length - 1\r\n    let response\r\n    try {\r\n      response = await fetch(url)\r\n    } catch (error) {\r\n      console.error('Failed to fetch list', listUrl, error)\r\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\r\n      continue\r\n    }\r\n\r\n    if (!response.ok) {\r\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\r\n      continue\r\n    }\r\n\r\n    const json = await response.json()\r\n    if (!tokenListValidator(json)) {\r\n      const validationErrors: string =\r\n        tokenListValidator.errors?.reduce<string>((memo, error) => {\r\n          const add = `${(error as any).dataPath} ${error.message ?? ''}`\r\n          return memo.length > 0 ? `${memo}; ${add}` : `${add}`\r\n        }, '') ?? 'unknown error'\r\n      throw new Error(`Token list failed validation: ${validationErrors}`)\r\n    }\r\n    return json as TokenList\r\n  }\r\n  throw new Error('Unrecognized list URL protocol.')\r\n}\r\n"],"sourceRoot":""}